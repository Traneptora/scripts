#!/bin/sh
. tbz-common.sh
#set -x

# thebombzen's easy video clipping script
#
# Dependencies: These must be in your path
# 1. bash (this is a bash script)
# 2. ffmpeg
# 3. awk
# 4. mkvmerge (if outputting to matroska)
#
# Usage:
#     clipvideo INPUT_FILENAME OUTPUT_FILENAME --start=START_TIMECODE --end=END_TIMECODE [options]
#
# This will create (and overwrite!) output_filename as input_filename but temporally clipped between the timecodes
# Option order does not matter for the most part, and options can be inserted anywhere among the initial filenames, --start, and --end. 
# If the same option is specified twice, the second one wins.
# Some options can be specified more than once. See below.
#
# Note: To streamcopy rather than re-encode, it's much faster and there's no quality loss, but the timecodes will be inaccurate.
# You will get more video and audio than you bargained for.
# To do this, use:
#     clipvideo INPUT_FILENAME OUTPUT_FILENAME --start=START_TIMECODE --end=END_TIMECODE --codec=copy --acodec=copy --ffopts='-c copy'
#
# If you want to copy always, no matter what, then add this line to ~/.bashrc
#     alias clipvideo='clipvideo --codec=copy --acodec copy --ffopts="-c copy"'
#
# Most options have very sane defaults (that's the point of the script, tbh).
# You should not touch them unless you know why.
#
# Options:
# --subs=VALUE
#     VALUE can be hard, to burn the subtitles into the video
#                  soft, to copy the subtitle stream and any attachments
#                  image, to burn image subtitles into the video (this is hard to autodetect)
#                  no (default), do not copy subtitles
#
# --ffmpeg=VALUE
#     Path to FFmpeg, if it's not in the environment variable PATH.
#     Allows you to select a specific one if more than one is installed.
#     Default: ffmpeg
#
# --size=VALUE
#     Scale the video to size VALUE. Give it in WxH. (e.g. 1280x720)
#     Default: Same as input. (i.e. do nothing)
#
# --fps=VALUE
#     Duplicate and drop frames to achieve the framerate VALUE.
#     Default: Same as input. (i.e. do nothing)
#
# --format=VALUE
#     Output to the pixel format VALUE.
#     Warning: This is not the file format. The file format is autodetected from the filename.
#     Default: Automatically select the appropriate output pixel format.
#
# --aid=VALUE
#     VALUE is the index of the audio stream you want to clip.
#     It starts at 0, not 1. Append '?' to make it not error if there's no audio.
#     Default: 0?
#
# --sid=VALUE
#     VALUE is the index of the subtitle stream you want to clip.
#     It starts at 0, not 1. Append '?' to make it not error if there's no subtitles.
#     Default: 0?
#
# --codec=VALUE
#     Set the video codec.
#     These use libavcodec names. Most common names are added as aliases.
#     Default: libx264.
#
# --bitrate=VALUE
#     Set the video bitrate in bits per second.
#     Set to "vbr" to use VBR encoding for video.
#     supports 'k' and 'M' as suffixes.
#     Default: vbr
#
# --quality=VALUE
#     Set the VBR quality. For x264, x265, vp8, and vp9, this is the CRF value. For others, it's a constant QP.
#     Note: Lower is higher quality. Setting it to 0 is lossless.
#     Note: This option does absolutely nothing for lossless codecs.
#     Default: CRF 16 for x264, x265, vp8, and vp9. QP 25 for others.
#
# --filter=VALUE
#     Add a libavfilter-syntax video filtergraph.
#     This option can be specified multiple times.
#     Default: No video filter.
#
# --ffopts=VALUE
#     Add extra options to the ffmpeg execution.
#     This option can be specified multiple times.
#     Default: No extra options.
#
# --pause
#     Ignored. (mpv compatibility)
#
# --mute
#     Ignored. (mpv compatibility)
#

VIDEOSTREAM="v:0?"
AUDIOSTREAM="a:0?"
VIDEOINPUT=""
VIDEOOUTPUT=""
ARGSDONE="no"
SUBS="no"
SID=0
START=""
END=""
VENCODER="libx264"
BITRATE="vbr"
PIXEL_FORMAT=""
FFOPTS=""
FILTER="copy"
QUALITY=""
SIZE=""
FPS=""
FFMPEG="ffmpeg"
LIBX264SO=""
AENCODER=""
SENCODER="subrip"
CONTAINER=""
X265OPTS="aq-mode=3:bframes=8:psy-rd=1.0"
X264OPTS="aq-mode=3:bframes=8"
USE_MKVMERGE="false"
FORCE="false"
FORMATOPTS=""
subslink=".clipvideo_subsymlink"
REMUX_MOVMP4="false"
SPEED="1.0"
AFILTER="acopy"
SPEEDCHANGER=""
AAC_ENCODER="aac"
STARTOPTS=""

remove_subslink(){
	rm -f "$subslink"
}

add_cleanup_routine remove_subslink


BAD_METADATA="BPS DURATION NUMBER_OF_FRAMES NUMBER_OF_BYTES _STATISTICS_WRITING_APP _STATISTICS_WRITING_DATE_UTC _STATISTICS_TAGS"
BAD_MD_OPTS=""

for tag in $BAD_METADATA; do
	BAD_MD_OPTS="$BAD_MD_OPTS -metadata:s ${tag}= -metadata:s ${tag}-eng="
done

process_option(){
	NAME="$1"
	VALUE="$2"
	NAMEL="$(__ tolower "$NAME")"
	VALUEL="$(__ tolower "$VALUE")"
	case "$NAMEL" in
		subs)
			case "$VALUEL" in
				hard|soft|image|no)
					SUBS="$VALUEL"
					;;
				*)
					error "Invalid --subs= value." "Accepted values: hard, soft, image, no"
					;;
			esac
			;;
		vid)
			VIDEOSTREAM="v:$VALUE"
			;;
		aid)
			AUDIOSTREAM="a:$VALUE"
			;;
		end)
			END="$VALUE"
			;;
		start)
			START="$VALUE"
			;;
		bitrate)
			BITRATE="$VALUE"
			;;
		codec)
			VENCODER="$VALUEL"
			;;
		scodec)
			SENCODER="$VALUEL"
			;;
		sid)
			SID="$VALUE"
			;;
		ffopts)
			FFOPTS="$FFOPTS $VALUE"
			;;
		ffmpeg|ffmpeg-exe)
			FFMPEG="$VALUE"
			;;
		format)
			error_nonfatal "--format is deprecated. Use --pixel-format instead."
			PIXEL_FORMAT="$VALUEL"
			;;
		pixel-format)
			PIXEL_FORMAT="$VALUEL"
			;;
		size|geometry)
			SIZE="$VALUEL"
			;;
		fps)
			FPS="$VALUE"
			;;
		filter)
			FILTER="$FILTER,$VALUE"
			;;
		vf)
			if matches "$VALUE" '^lavfi=".*"$' ; then
				note "Using vf=lavfi compatibility."
				VALUE="${VALUE#lavfi=\"}"
				VALUE="${VALUE%\"}"
				FILTER="$FILTER,$VALUE"
			else
				error 'Only vf=lavfi is an alias for "filter"'
			fi
			;;
		afilter)
			AFILTER="$AFILTER,$VALUE"
			;;
		x265opts)
			X265OPTS="${X265OPTS}:$VALUE"
			;;
		x264opts)
			X264OPTS="${X264OPTS}:$VALUE"
			;;
		libx264-so|libx264-shared)
			LIBX264SO="$VALUE"
			;;
		use-mkvmerge)
			USE_MKVMERGE="true"
			;;
		remux-movmp4)
			REMUX_MOVMP4="true"
			;;
		acodec)
			AENCODER="$VALUEL"
			;;
		container|container-format)
			CONTAINER="$VALUEL"
			;;
		qp)
			error_nonfatal "--qp is deprecated. Use --quality instead."
			QUALITY="$VALUE"
			;;
		quality)
			QUALITY="$VALUE"
			;;
		speed)
			SPEED="$VALUE"
			;;
		force)
			warning "Disabling sanity checks and aliases. Errors are your fault!"
			FORCE="true"
			;;
		# mpv compatibility
		pause|mute|loop-playlist|loop-file)
			note "Ignoring --${NAME}"
			;;
		*)
			error "Invalid option: $NAME"
			;;
	esac
}

process_naked_argument(){
	if [ -z "$VIDEOINPUT" ] ; then
		VIDEOINPUT="$arg"
	elif [ -z "$VIDEOOUTPUT" ] ; then
		VIDEOOUTPUT="$arg"
	else
		error "Invalid trailing argument: $arg"
	fi
}

option_processor=process_option naked_argument_processor=process_naked_argument parse_arguments "$@"

ffmpeg(){
	if [ -n "$LIBX264SO" ] ; then
		# Yes, this is really necessary
		env LD_PRELOAD="$LIBX264SO" sh -c 'exec "$@"' sh "$FFMPEG" "$@"
	else
		# This is necessary to prevent an infinite loop if "$FFMPEG" is "ffmpeg"
		sh -c 'exec "$@"' sh "$FFMPEG" "$@"
	fi
}

ffmpeg_v(){
	printf '%s %s\n' "$FFMPEG" "$*"
	ffmpeg "$@"
}

if [ -z "${VIDEOINPUT}" ] || [ -z "${VIDEOOUTPUT}" ] ; then
	error "Provide both a video input and output."
fi

if [ -z "$START" ] && [ -z "$END" ] ; then
	warning "Clipping the entire video."
fi

if [ -z "$START" ] ; then
	START=0
fi

if fmatches "$SUBS" 'image' 'hard' && [ "$VENCODER" = "copy" ] ; then
	error "Cannot codec copy when hardsubbing."
fi

if matches "$PIXEL_FORMAT" '^nv' '^p0' ; then
	error "Use planar pixel formats."
fi

grep_args="-i"
if [ -z "$CONTAINER" ] ; then
	if matches "$VIDEOOUTPUT" '\.(mkv|mka|mk3d|mks)$' ; then
		CONTAINER="matroska"
	elif matches "$VIDEOOUTPUT" '\.(ts|tsv|tsa|mpegts)$' ; then
		CONTAINER="mpegts"
	elif matches "$VIDEOOUTPUT" '\.(nut)$' ; then
		CONTAINER="nut"
	elif matches "$VIDEOOUTPUT" '\.(mp4|m4a|m4v)$' ; then
		CONTAINER="mp4"
	elif matches "$VIDEOOUTPUT" '\.(ogg|oga|ogv)$' ; then
		CONTAINER="ogg"
	elif matches "$VIDEOOUTPUT" '\.(webm)$' ; then
		CONTAINER="webm"
	elif matches "$VIDEOOUTPUT" '\.(mov)$' ; then
		CONTAINER="mov"
	else
		CONTAINER="auto"
	fi
elif ! checkvar FORCE ; then
	case "$CONTAINER" in
		mkv|mka|mk3d|mks)
			warning "$CONTAINER is an alias for matroska."
			CONTAINER="matroska"
			;;
		ts|tsa|tsv)
			warning "$CONTAINER is an alias for mpegts."
			CONTAINER="mpegts"
			;;
		m4a|m4v)
			warning "$CONTAINER is an alias for mp4."
			CONTAINER="mp4"
			;;
		ogv|oga)
			warning "$CONTAINER is an alias for ogg."
			CONTAINER="ogg"
			;;
	esac
fi
unset grep_args

if ffmpeg -v panic -f lavfi -i anullsrc -c:a libfdk_aac -t 1 -b:a 128k -f null - ; then
	AAC_ENCODER="libfdk_aac"
else
	AAC_ENCODER="aac"
fi

if [ -z "$AENCODER" ] ; then
	case "$CONTAINER" in
		matroska|mpegts|nut|webm)
			AENCODER="libopus"
			;;
		mp4|mov)
			AENCODER="$AAC_ENCODER"
			;;
		ogg)
			AENCODER="libvorbis"
			;;
		*)
			AENCODER="auto"
			;;
	esac
fi

if ! checkvar FORCE ; then case "$AENCODER" in
	mp3)
		note "$AENCODER is an alias for libmp3lame."
		AENCODER="libmp3lame"
		;;
	opus)
		note "$AENCODER is an alias for libopus."
		AENCODER="libopus"
		;;
	libvo-aacenc|libvo_aacenc)
		warning "$AENCODER is an alias for '$AAC_ENCODER' because $AENCODER is unbelievably terrible."
		AENCODER="$AAC_ENCODER"
		;;
	vorbis)
		note "$AENCODER is an alias for libvorbis."
		AENCODER="libvorbis"
		;;
esac; fi

case "$AENCODER" in
	libopus)
		AUDIOOPTS="-c:a $AENCODER -b:a 160k -ac:a 2"
		;;
	libvorbis)
		AUDIOOPTS="-c:a $AENCODER -q:a 6"
		;;
	aac|libfdk_aac)
		AUDIOOPTS="-c:a $AENCODER -b:a 160k"
		;;
	libmp3lame)
		AUDIOOPTS="-c:a $AENCODER -b:a 256k"
		;;
	# lossless stuff
	copy|ape|pcm*)
		AUDIOOPTS="-c:a $AENCODER"
		;;
	# more lossless
	flac|alac)
		AUDIOOPTS="-c:a $AENCODER -compression_level:a 12"
		;;
	*)
		AUDIOOPTS="-c:a $AENCODER -b:a 128k"
		;;
esac

FORMATOPTS="$FORMATOPTS -f $CONTAINER"

case "$CONTAINER" in
	matroska)
		if checkvar USE_MKVMERGE; then
			VIDEOOUTPUT="$VIDEOOUTPUT".mkv
		fi
		SENCODER="ass"
		;;
	webm)
		if checkvar USE_MKVMERGE ; then
			VIDEOOUTPUT="$VIDEOOUTPUT".webm
		fi
		SENCODER="webvtt"
		;;
	mp4)
		FORMATOPTS="$FORMATOPTS -movflags +faststart"
		if [ "$AENCODER" = "libopus" ] ; then
			FORMATOPTS="$FORMATOPTS -strict experimental"
		fi
		if checkvar REMUX_MOVMP4 ; then
			VIDEOOUTPUT="$VIDEOOUTPUT".nut
			FORMATOPTS="$FORMATOPTS -f nut"
		fi
		SENCODER="mov_text"
		;;
	mov)
		FORMATOPTS="$FORMATOPTS -movflags +faststart"
		if checkvar REMUX_MOVMP4 ; then
			VIDEOOUTPUT="$VIDEOOUTPUT".nut
			FORMATOPTS="$FORMATOPTS -f nut"
		fi
		SENCODER="mov_text"
		;;
esac

if ! checkvar FORCE ; then case "$VENCODER" in
	nvenc|nvenc_h264)
		warning "$VENCODER is a deprecated alias for h264_nvenc."
		VENCODER="h264_nvenc"
		;;
	nvenc_hevc)
		warning "$VENCODER is a deprecated alias for hevc_nvenc."
		VENCODER="hevc_nvenc"
		;;
	h264|avc|x264)
		note "$VENCODER is an alias for libx264."
		VENCODER="libx264"
		;;
	h265|hevc|x265)
		note "$VENCODER is an alias for libx265."
		VENCODER="libx265"
		;;
	vp8|libvpx-vp8)
		warning "$VENCODER is an alias for libvpx."
		VENCODER="libvpx"
		;;
	vp9)
		note "$VENCODER is an alias for libvpx-vp9."
		VENCODER="libvpx-vp9"
		;;
esac; fi

if [ -z "$QUALITY" ] ; then
	case "$VENCODER" in
		libx26?|libvpx*)
			QUALITY=16
			;;
		*)
			QUALITY=25
			;;
	esac
fi

if [ "$BITRATE" = "vbr" ] ; then
	case "$VENCODER" in
		libx26?)
			if [ "$QUALITY" -eq 0 ] ; then
				# This is truly lossless for 10-bit avc
				BITRATEOPTS="-qp:v 0"
			else
				BITRATEOPTS="-crf:v $QUALITY"
			fi
			;;
		libvpx*)
			BITRATEOPTS="-b:v 0 -crf:v $QUALITY"
			;;
		# These are lossless
		copy|ffvhuff|huffyuv|utvideo|ffv1|rawvideo|wrapped_avframe|png|ppm|gif|bmp)
			BITRATEOPTS=""
			;;
		*)
			BITRATEOPTS="-qp:v $QUALITY"
			;;
	esac
else
	BITRATEOPTS="-b:v $BITRATE"
fi

case "$VENCODER" in
	h264_nvenc)
		VIDEOOPTS="-c:v h264_nvenc -preset:v slow -profile:v high -spatial-aq:v 1 -qmin:v 0 -qmax:v 69"
		;;
	libx264)
		VIDEOOPTS="-c:v libx264 -preset:v slow -x264opts ${X264OPTS}"
		;;
	libx265)
		VIDEOOPTS="-c:v libx265 -preset:v slow -x265-params ${X265OPTS}"
		;;
	# The _ in spacial_aq is intentional
	# Nvenc is weird
	hevc_nvenc)
		VIDEOOPTS="-c:v hevc_nvenc -preset:v slow -tier:v 1 -rc-lookahead:v 120 -spatial_aq:v 1"
		;;
	ffv1)
		VIDEOOPTS="-c:v ffv1 -level:v 3 -g:v 1 -slicecrc:v 1 -coder:v range_tab -slices:v 4 -threads:v 4"
		;;
	*)
		VIDEOOPTS="-c:v $VENCODER"
		;;
esac

if [ "$(__ num_compare "$SPEED" 1.0)" -ne 0 ] ; then
	if ffmpeg -v error -f lavfi -i anullsrc -af rubberband=tempo=0.5 -t 1 -f null -; then
		SPEEDSCALER="rubberband=tempo="
	else
		SPEEDSCALER="atempo="
	fi
	AFILTER="${AFILTER},${SPEEDSCALER}${SPEED}"
	FILTER="${FILTER},setpts=PTS/${SPEED}"
fi

if [ -z "$PIXEL_FORMAT" ] ; then
	case "$VENCODER" in
		*_nvenc)
			if ffmpeg -v error -f lavfi -i yuvtestsrc -vf scale,format=yuv420p10le -pix_fmt yuv420p10le -c "$VENCODER" -frames 1 -f nut - | ffprobe -v error -show_entries stream=pix_fmt -of default=noprint_wrappers=1:nokey=1 -f nut -i - | grep -q -e '10le$'; then
				PIXEL_FORMAT=yuv420p10le
			else
				PIXEL_FORMAT=yuv420p
			fi
			;;
		libx26?)
			if ffmpeg -v error -f lavfi -i yuvtestsrc -vf scale,format=yuv420p10le -pix_fmt yuv420p10le -c "$VENCODER" -frames 1 -f nut - | ffprobe -v error -show_entries stream=pix_fmt -of default=noprint_wrappers=1:nokey=1 -f nut -i - | grep -q -e '10le$'; then
				PIXEL_FORMAT=yuv420p10le
			else
				PIXEL_FORMAT=yuv420p
			fi
			;;
		*)
			PIXEL_FORMAT="auto"
			;;
	esac
fi

if ffmpeg -v panic -f lavfi -i yuvtestsrc -vf zscale -frames 1 -f null -; then
	scaler(){
		if matches "$PIXEL_FORMAT" 'bgr' 'rgb' 'gbr' 'bayer' ; then
			printf 'zscale=%s:f=spline36:range=pc' "$1"
		else
			printf 'zscale=%s:f=spline36:range=tv' "$1"
		fi
	}
else
	scaler(){
		printf 'scale=%s:interl=-1:flags=lanczos' "$(__ readfrom "$1" tr 'x' ':')"
	}
fi

if [ -n "$FPS" ] ; then
	FILTER="${FILTER},fps=${FPS}"
fi

if [ -n "$SIZE" ] ; then
	FILTER="${FILTER},$(scaler $SIZE)"
else
	FILTER="${FILTER},$(scaler w=iw:h=ih)"
fi

if [ "$PIXEL_FORMAT" != "auto" ] ; then
	FILTER="${FILTER},format=${PIXEL_FORMAT}"
	if matches "$PIXEL_FORMAT" 'bgr' 'rgb' 'gbr' 'bayer' ; then
		FORMATOPTS="$FORMATOPTS -color_range pc"
	else
		FORMATOPTS="$FORMATOPTS -color_range tv"
	fi
fi

time_duration_toseconds() {
	__ readfrom "$1" awk -F: '{ n = 1; for (i = NF; i > 0; i--) { out = $i * n + out; n = n * 60 } print out }'
}

STARTSECS="$(time_duration_toseconds "$START")"

if [ -n "$END" ] ; then
	ENDSECS="$(time_duration_toseconds "$END")"
	DURATION="$(awk "BEGIN { print ( $ENDSECS - $STARTSECS ) / $SPEED }")"
fi

if [ "$SUBS" = "hard" ] ; then
	ln -sf "$VIDEOINPUT" "$subslink"
fi

FILTER="${FILTER##,}"
FILTER="${FILTER%%,}"
FILTER="$(__ readfrom "$FILTER" sed -r 's/,+/,/g')"

FORMATOPTS="$FORMATOPTS $BAD_MD_OPTS"

case "$SUBS" in
	image)
		FILTER="[s:${SID}]overlay,setpts=PTS-$STARTSECS/TB,$FILTER"
		AFILTER="asetpts=PTS-STARTPTS,$AFILTER"
		;;
	hard)
		FILTER="subtitles=filename=$subslink:si=$SID,setpts=PTS-$STARTSECS/TB,${FILTER}"
		AFILTER="asetpts=PTS-STARTPTS,$AFILTER"
		;;
esac

if is_gt "$STARTSECS" 0 ; then
	STARTOPTS="-ss $STARTSECS"
	if [ "$SUBS" = "image" ] || [ "$SUBS" = "hard" ] ; then
		STARTOPTS="$STARTOPTS -copyts -start_at_zero"
	fi
fi

set --

if [ -n "$END" ] ; then
	set -- "$@" "-t" "$DURATION"
fi

if [ "$VENCODER" != "copy" ] ; then
	set -- "$@" "-vf" "$FILTER"
fi

if [ "$AENCODER" != "acopy" ] ; then
	set -- "$@" "-af" "$AFILTER"
fi

if [ "$SUBS" = "image" ] ; then
	set -- -map "$AUDIOSTREAM" "$@"
elif [ "$SUBS" = "soft" ] ; then
	set -- -map "$VIDEOSTREAM" -map "$AUDIOSTREAM" -map s:"$SID" -map t? -map d? -c copy -c:s "$SENCODER" "$@"
elif [ "$SUBS" = "hard" ] ; then
	if [ -n "$FILTER" ] ; then FILTER=",$FILTER"; fi
	set -- -map "$VIDEOSTREAM" -map "$AUDIOSTREAM" "$@"
else
	set -- -map "$VIDEOSTREAM" -map "$AUDIOSTREAM" -c copy "$@"
fi

set -- "-hide_banner" "-y" $STARTOPTS -i "$VIDEOINPUT" "$@" $VIDEOOPTS $BITRATEOPTS $AUDIOOPTS $FORMATOPTS $FFOPTS "$VIDEOOUTPUT"

ffmpeg_v "$@"

if checkvar USE_MKVMERGE && fmatches "$CONTAINER" matroska webm ; then
	MKVMERGEOPTS="--verbose"
	if [ -n "$FPS" ] ; then
		MKVMERGEOPTS="$MKVMERGEOPTS --default-duration 0:${FPS}fps"
	fi
	mkvmerge --verbose $MKVMERGEOPTS -o "${VIDEOOUTPUT%.*}" "$VIDEOOUTPUT"
	rm -f "$VIDEOOUTPUT"
fi

if checkvar REMUX_MOVMP4 && fmatches "$CONTAINER" mov mp4; then
	ffmpeg -hide_banner -y -i "$VIDEOOUTPUT" -map 0 -c copy $FORMATOPTS -f "$CONTAINER" "${VIDEOOUTPUT%.nut}"
	rm -f "$VIDEOOUTPUT"
fi
