#!/usr/bin/env bash
set -e; set +H

# thebombzen's easy video clipping script
#
# Dependencies: These must be in your path
# 1. bash (this is a bash script)
# 2. ffmpeg
# 3. awk
# 4. mkvmerge (if outputting to matroska)
#
# Usage:
#     clipvideo INPUT_FILENAME OUTPUT_FILENAME --start=START_TIMECODE --end=END_TIMECODE [options]
#
# This will create (and overwrite!) output_filename as input_filename but temporally clipped between the timecodes
# Option order does not matter for the most part, and options can be inserted anywhere among the initial filenames, --start, and --end. 
# If the same option is specified twice, the second one wins.
# Some options can be specified more than once. See below.
#
# Note: To streamcopy rather than re-encode, it's much faster and there's no quality loss, but the timecodes will be inaccurate.
# You will get more video and audio than you bargained for.
# To do this, use:
#     clipvideo INPUT_FILENAME OUTPUT_FILENAME --start=START_TIMECODE --end=END_TIMECODE --codec=copy --ffopts='-c copy'
#
# If you want to copy always, no matter what, then add this line to ~/.bashrc
#     alias clipvideo='clipvideo --codec=copy --ffopts="-c copy"'
#
# Most options have very sane defaults (that's the point of the script, tbh).
# You should not touch them unless you know why.
#
# Options:
# --subs=VALUE
#     VALUE can be hard, to burn the subtitles into the video
#                  soft, to copy the subtitle stream and any attachments
#                  image, to burn image subtitles into the video (this is hard to autodetect)
#                  no (default), do not copy subtitles
#
# --ffmpeg=VALUE
#     Path to FFmpeg, if it's not in the environment variable PATH.
#     Allows you to select a specific one if more than one is installed.
#     Default: ffmpeg
#
# --size=VALUE
#     Scale the video to size VALUE. Give it in WxH. (e.g. 1280x720)
#     Default: Same as input. (i.e. do nothing)
#
# --fps=VALUE
#     Duplicate and drop frames to achieve the framerate VALUE.
#     Default: Same as input. (i.e. do nothing)
#
# --format=VALUE
#     Output to the pixel format VALUE.
#     Warning: This is not the file format. The file format is autodetected from the filename.
#     Default: Automatically select the appropriate output pixel format.
#
# --aid=VALUE
#     VALUE is the index of the audio stream you want to clip.
#     It starts at 0, not 1. Append '?' to make it not error if there's no audio.
#     Default: 0?
#
# --sid=VALUE
#     VALUE is the index of the subtitle stream you want to clip.
#     It starts at 0, not 1. Append '?' to make it not error if there's no subtitles.
#     Default: 0
#
# --codec=VALUE
#     Set the video codec.
#     These use libavcodec names. x264, x265, h264, and hevc are added as aliases, so these work.
#     Default: libx264.
#
# --bitrate=VALUE
#     Set the video bitrate in bits per second.
#     Set to "vbr" to use VBR encoding for video.
#     supports 'k' and 'M' as suffixes.
#     Default: vbr
#
# --qp=VALUE
#     Set the VBR quality. For x264 and x265, this is the CRF value. For others, it's a constant QP.
#     Note: Lower is higher quality. Setting it to 0 is lossless.
#     Note: This does absolutely nothing for lossless codecs.
#     Default: CRF 16 for x264 and x265, 25 for others.
#
# --filter=VALUE
#     Add a libavfilter-syntax video filtergraph.
#     This option can be specified multiple times.
#     Default: No video filter.
#
# --ffopts=VALUE
#     Add extra options to the ffmpeg execution.
#     This option can be specified multiple times.
#     Default: No extra options.
#
# --pause
#     Ignored. (mpv compatibility)
#
# --mute
#     Ignored. (mpv compatibility)
#

VIDEOSTREAM="v"
AUDIOSTREAM="a:0?"
VIDEOINPUT=""
VIDEOOUTPUT=""
ARGSDONE="no"
SUBS="no"
SID=0
START=""
END=""
ENCODER="libx264"
BITRATE="vbr"
FORMAT=""
FFOPTS=""
FILTER=""
QP=""
SIZE=""
FPS=""
FFMPEG="ffmpeg"

BAD_METADATA="BPS DURATION NUMBER_OF_FRAMES NUMBER_OF_BYTES _STATISTICS_WRITING_APP _STATISTICS_WRITING_DATE_UTC _STATISTICS_TAGS"
BAD_MD_OPTS=""

for tag in $BAD_METADATA; do
	BAD_MD_OPTS="$BAD_MD_OPTS -metadata:s ${tag}= -metadata:s ${tag}-eng="
done

process_option(){
	NAME="$1"
	VALUE="$2"
	case "$NAME" in
		subs)
			if [ "x$VALUE" = "xhard" ] ; then
				SUBS="hard"
			elif [ "x$VALUE" = "ximage" ] ; then
				SUBS="image"
			elif [ "x$VALUE" = "xsoft" ] ; then
				SUBS="soft"
			fi
			;;
		aid)
			AUDIOSTREAM="a:$VALUE"
			;;
		end)
			END="$VALUE"
			;;
		start)
			START="$VALUE"
			;;
		bitrate)
			BITRATE="$VALUE"
			;;
		codec)
			case "$VALUE" in
				nvenc)
					ENCODER="h264_nvenc"
					;;
				h264)
					ENCODER="libx264"
					;;
				hevc)
					ENCODER="libx265"
					;;
				x264)
					ENCODER="libx264"
					;;
				x265)
					ENCODER="libx265"
					;;
				*)
					ENCODER="$VALUE"
					;;
			esac
			;;
		sid)
			SID="$VALUE"
			;;
		ffopts)
			FFOPTS="$FFOPTS $VALUE"
			;;
		ffmpeg)
			FFMPEG="$VALUE"
			;;
		format)
			FORMAT="$VALUE"
			;;
		size)
			SIZE="$VALUE"
			;;
		fps)
			FPS="$VALUE"
			;;
		filter)
			if [ -z "$FILTER" ] ; then
				FILTER="$VALUE"
			else
				FILTER="$FILTER,$VALUE"
			fi
			;;
		pause)
			>&2 echo "Note: Ignoring --pause"
			;;
		mute)
			>&2 echo "Note: Ignoring --mute"
			;;
		qp)
			QP="$VALUE"
			;;
		*)
			>&2 echo "Invalid option: $NAME=$VALUE"
			exit 1
			;;
	esac
}

for arg; do
	if [[ "x$ARGSDONE" != "xyes" && "$arg" =~ ^-- ]] ; then
		if [ "x$arg" = "x--" ] ; then
			ARGSDONE="yes"
		elif [[ ! "$arg" =~ = ]] ; then
			process_option "${arg#--}" "${arg#--}"
		else
			process_option "$(sed 's/^--\([^=]*\)=\(.*\)$/\1/' <<<"$arg")" "$(sed 's/^--\([^=]*\)=\(.*\)$/\2/' <<<"$arg")"
		fi
	elif [ -z "$VIDEOINPUT" ] ; then
		VIDEOINPUT="$arg"
	elif [ -z "$VIDEOOUTPUT" ] ; then
		VIDEOOUTPUT="$arg"
	else
		echo "Invalid trailing argument: $arg" >&2
		exit 1
	fi
done

if [[ -z "${VIDEOINPUT}" || -z "${VIDEOOUTPUT}" ]] ; then
	echo "Provide both a video input and output." >&2
	exit 1
fi

if [[ -z "$START" || -z "$END" ]] ; then
	echo "Need both a start and end timecode." >&2
	exit 1
fi

if $FFMPEG -v panic -f lavfi -i nullsrc -vf zscale -frames 1 -f null -; then
	SCALER=zscale=f=spline16:
else
	SCALER=scale=
fi

if [ -z "$FORMAT" ] ; then
	case $ENCODER in
		libx26?|*_nvenc)
			if $FFMPEG -v error -f lavfi -i nullsrc -pix_fmt p010le -c libx264 -frames 1 -f nut - | ffprobe -v error -show_entries stream=pix_fmt -of default=noprint_wrappers=1:nokey=1 -f nut -i - | grep -q -e '10le$'; then
				FORMAT=p010le
			else
				FORMAT=nv12
			fi
			;;
		*)
			FORMAT="auto"
			;;
	esac
fi

if [ -z "$QP" ] ; then
	case $ENCODER in
		libx26?)
			QP=16
			;;
		*)
			QP=25
			;;
	esac
fi

if [ -n "$FPS" ] ; then
	FILTER="${FILTER},fps=$FPS"
fi

if [ -n "$SIZE" ] ; then
	FILTER="${FILTER},${SCALER}size=$SIZE"
	if [ "$FORMAT" != "auto" ] ; then
		FILTER="${FILTER},format=${FORMAT}"
	fi
else
	if [ "$FORMAT" != "auto" ] ; then
		FILTER="${FILTER},${SCALER}w=iw:h=ih,format=${FORMAT}"
	fi
fi

FILTER="${FILTER##,}"
FILTER="${FILTER%%,}"

time_duration_toseconds() {
	awk -F: '{ n = 1; for (i = NF; i > 0; i--) { out = $i * n + out; n = n * 60 } print out }'
}

STARTSECS="$(time_duration_toseconds <<<"$START")"
ENDSECS="$(time_duration_toseconds <<<"$END")"

DURATION="$(awk '{ print $2 - $1 }' <<<"$STARTSECS $ENDSECS")"

subslink=".clipvideo_subsymlink"

if [ "x$SUBS" = "xhard" ] ; then
	rm -f "$subslink"
	ln -s "$VIDEOINPUT" "$subslink"
	FILTER="subtitles=filename=$subslink:si=$SID,$FILTER"
fi

FORMATOPTS=""
MATROSKA_COMPAT=false

if [[ "$VIDEOOUTPUT" =~ \.(mkv|MKV)$ ]] ; then
	MATROSKA_COMPAT=true
	AUDIOOPTS="-c:a libopus -b:a 128k -ac 2"
	VIDEOOUTPUT="$VIDEOOUTPUT".mkv
elif [[ "$VIDEOOUTPUT" =~ \.(ts|TS)$ ]] ; then
	AUDIOOPTS="-c:a libopus -b:a 128k -ac 2"
elif [[ "$VIDEOOUTPUT" =~ \.(nut|NUT)$ ]] ; then
	AUDIOOPTS="-c:a libopus -b:a 128k -ac 2"
elif [[ "$VIDEOOUTPUT" =~ \.(mp4|MP4)$ ]] ; then
	FORMATOPTS="-movflags +faststart"
	AUDIOOPTS="-c:a aac -b:a 128k"
else
	AUDIOOPTS="-c:a libvorbis -q:a 5"
fi

if [ "x$BITRATE" = "xvbr" ] ; then
	case "$ENCODER" in
		libx26?)
			BITRATEOPTS="-crf:v $QP"
			;;
		# These are lossless
		ffvhuff|huffyuv|utvideo|ffv1|rawvideo|wrapped_avframe|png)
			BITRATEOPTS=""
			;;
		*)
			BITRATEOPTS="-qp:v $QP"
			;;
	esac
else
	BITRATEOPTS="-b:v $BITRATE"
fi

case "$ENCODER" in
	h264_nvenc)
		VIDEOOPTS="-c:v h264_nvenc -gpu:v 0 -preset:v slow -profile:v high -spatial-aq:v 1 -qmin:v 0 -qmax:v 69"
		;;
	libx264)
		VIDEOOPTS="-c:v libx264 -preset:v slow -aq-mode:v 3 -bf:v 8"
		;;
	libx265)
		VIDEOOPTS="-c:v libx265 -preset:v slow -aq-mode:v 3 -bf:v 8"
		;;
	# The _ in spacial_aq is intentional
	# Nvenc is weird
	hevc_nvenc)
		VIDEOOPTS="-c:v hevc_nvenc -gpu:v 0 -preset:v slow -profile:v main10 -tier:v 1 -rc-lookahead:v 54 -surfaces:v 64 -spatial_aq:v 1"
		;;
	ffv1)
		VIDEOOPTS="-c:v ffv1 -level:v 3 -g:v 1 -slicecrc:v 1 -coder:v range_tab -slices:v 4 -threads:v 4"
		;;
	*)
		VIDEOOPTS="-c:v $ENCODER"
		;;
esac

FORMATOPTS="$FORMATOPTS $BAD_MD_OPTS"
FILTEROPTS=()
if [ -n "$FILTER" ] ; then
	FILTEROPTS+=("-vf")
	FILTEROPTS+=("$FILTER")
fi


if [ "x$SUBS" = "ximage" ] ; then
	if [ -n "$FILTER" ] ; then FILTER=",$FILTER"; fi
	set -x
	time "$FFMPEG" -ss "$START" -copyts -start_at_zero -i "$VIDEOINPUT" -lavfi "[0:v][0:s:${SID}]overlay,setpts=PTS-STARTPTS${FILTER}[v]" -map "[v]" -map "$AUDIOSTREAM" -t "$DURATION" -af "asetpts=PTS-STARTPTS" $VIDEOOPTS $BITRATEOPTS $AUDIOOPTS $FORMATOPTS $FFOPTS -y "$VIDEOOUTPUT"
	set +x
elif [ "x$SUBS" = "xsoft" ] ; then
	set -x
	time "$FFMPEG" -ss "$START" -i "$VIDEOINPUT" -map "$VIDEOSTREAM" -map "$AUDIOSTREAM" -map 0:s:"$SID" -map t? -map d? -c copy -c:s ass -t "$DURATION" "${FILTEROPTS[@]}" $VIDEOOPTS $BITRATEOPTS $AUDIOOPTS $FORMATOPTS $FFOPTS -y "$VIDEOOUTPUT"
	set +x
elif [ "x$SUBS" = "xhard" ] ; then
	set -x
	time "$FFMPEG" -ss "$START" -copyts -start_at_zero -i "$VIDEOINPUT" -map "$VIDEOSTREAM" -map "$AUDIOSTREAM" -t "$DURATION" -vf "${FILTER},setpts=PTS-STARTPTS" -af "asetpts=PTS-STARTPTS" $VIDEOOPTS $BITRATEOPTS $AUDIOOPTS $FORMATOPTS $FFOPTS -y "$VIDEOOUTPUT"
	set +x
else
	set -x
	time "$FFMPEG" -ss "$START" -i "$VIDEOINPUT" -map "$VIDEOSTREAM" -map "$AUDIOSTREAM" -c copy -t "$DURATION" "${FILTEROPTS[@]}" $VIDEOOPTS $BITRATEOPTS $AUDIOOPTS $FORMATOPTS $FFOPTS -y "$VIDEOOUTPUT"
	set +x
fi

if $MATROSKA_COMPAT; then
	mkvmerge --verbose -o "${VIDEOOUTPUT%.mkv}" "$VIDEOOUTPUT"
	rm -f "$VIDEOOUTPUT"
fi

rm -f "$subslink"

